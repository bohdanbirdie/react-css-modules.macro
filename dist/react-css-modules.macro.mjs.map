{"version":3,"file":"react-css-modules.macro.mjs","sources":["../src/macro.js"],"sourcesContent":["const { createMacro } = require(\"babel-plugin-macros\");\nconst { name } = require(\"../package.json\");\n\nconst defaultConfig = {\n  enableMemo: true,\n  targetTag: \"styleName\",\n  warning: true,\n};\n\nconst ensureAttrName = attr => {\n  if (attr && attr.name && attr.name.name) {\n    return attr.name.name;\n  }\n\n  return \"\";\n};\n\nconst removeStyleNameAttr = (path, config) => {\n  path.node.openingElement.attributes = [\n    ...path.node.openingElement.attributes.filter(\n      attr => ensureAttrName(attr) !== config.targetTag,\n    ),\n  ];\n};\n\nconst createClassNameOmmitedSpread = (spreadAttr, t) => {\n  return t.JSXSpreadAttribute(\n    t.callExpression(\n      t.ArrowFunctionExpression(\n        [],\n        t.BlockStatement([\n          t.VariableDeclaration(\"const\", [\n            t.VariableDeclarator(\n              t.identifier(\"k\"),\n              t.ObjectExpression([t.SpreadElement(spreadAttr.argument)]),\n            ),\n          ]),\n          t.ExpressionStatement(\n            t.UnaryExpression(\n              \"delete\",\n              t.memberExpression(\n                t.identifier(\"k\"),\n                t.StringLiteral(\"className\"),\n                true,\n              ),\n            ),\n          ),\n          t.ReturnStatement(t.identifier(\"k\")),\n        ]),\n      ),\n      [],\n    ),\n  );\n};\n\nconst findStyleNameAttrIndex = (path, config, t) => {\n  const list = path.node.openingElement.attributes.map(attr => {\n    return t.isJSXAttribute(attr) && ensureAttrName(attr) === config.targetTag;\n  });\n\n  return list.indexOf(true);\n};\n\nconst findClassNameAttr = (path, t) => {\n  return path.node.openingElement.attributes.find(\n    attr => ensureAttrName(attr) === \"className\",\n  );\n};\n\nconst findJSXSpreadAttr = (path, t) => {\n  const propsSpread = path.node.openingElement.attributes.find(attr => {\n    return t.isJSXSpreadAttribute(attr);\n  });\n\n  if (propsSpread) {\n    return propsSpread;\n  }\n  return false;\n};\n\nconst getMemberExpressionFromSpread = (spread, t) => {\n  if (spread) {\n    return t.memberExpression(spread.argument, t.identifier(\"className\"));\n  }\n  return false;\n};\n\nconst createClassNameAttr = (t, value) => {\n  return t.JSXAttribute(t.jsxIdentifier(\"className\"), value);\n};\n\nconst getStyleNameAttrPayload = (t, styleNameAttr) => {\n  if (t.isStringLiteral(styleNameAttr.value)) {\n    if (!styleNameAttr.value.value) {\n      return undefined;\n    }\n    const stringValueReplacement = styleNameAttr.value.value\n      .split(\" \")\n      .map(val => t.stringLiteral(val));\n    if (stringValueReplacement.length > 1) {\n      return t.arrayExpression(stringValueReplacement);\n    }\n\n    if (stringValueReplacement[0]) {\n      return stringValueReplacement[0];\n    }\n\n    return undefined;\n  }\n\n  return styleNameAttr.value.expression;\n};\n\nconst visitor = (t, getStyleNameIdentifier, config) => ({\n  JSXElement(path) {\n    if (path.node.openingElement.attributes.length) {\n      const spreadAttr = findJSXSpreadAttr(path, t);\n      const classNameFromSpread = getMemberExpressionFromSpread(spreadAttr, t);\n      const styleNameAttrIndex = findStyleNameAttrIndex(path, config, t);\n\n      const styleNameAttr = path.node.openingElement.attributes.find(\n        attr => ensureAttrName(attr) === config.targetTag,\n      );\n\n      if (styleNameAttr) {\n        const styleNameAttrPayload = getStyleNameAttrPayload(t, styleNameAttr);\n\n        const styleNameExp = t.callExpression(getStyleNameIdentifier, [\n          ...[styleNameAttrPayload].filter(Boolean),\n        ]);\n        const classNameAttr = findClassNameAttr(path, t);\n\n        if (classNameAttr) {\n          if (styleNameAttrPayload) {\n            if (t.isJSXExpressionContainer(classNameAttr.value)) {\n              classNameAttr.value = t.JSXExpressionContainer(\n                t.binaryExpression(\n                  \"+\",\n                  classNameAttr.value.expression,\n                  styleNameExp,\n                ),\n              );\n            }\n\n            if (t.isStringLiteral(classNameAttr.value)) {\n              classNameAttr.value = t.JSXExpressionContainer(\n                t.binaryExpression(\"+\", classNameAttr.value, styleNameExp),\n              );\n            }\n          }\n          removeStyleNameAttr(path, config);\n        } else {\n          const newClassNameAttr = createClassNameAttr(\n            t,\n            t.JSXExpressionContainer(\n              spreadAttr\n                ? t.binaryExpression(\"+\", classNameFromSpread, styleNameExp)\n                : styleNameExp,\n            ),\n          );\n\n          path.node.openingElement.attributes[\n            styleNameAttrIndex\n          ] = newClassNameAttr;\n          const spreadIndex = path.node.openingElement.attributes.indexOf(\n            spreadAttr,\n          );\n\n          if (spreadIndex >= 0) {\n            path.node.openingElement.attributes[\n              spreadIndex\n            ] = createClassNameOmmitedSpread(spreadAttr, t);\n          }\n        }\n      }\n    }\n  },\n});\n\nconst getStylesArgument = path => path.parent.arguments[0];\n\nconst myMacro = ({ references, babel, config }) => {\n  const marcoConfig = { ...defaultConfig, ...config };\n  const { macro = [] } = references;\n  const { types: t } = babel;\n  macro.forEach(referencePath => {\n    const stylesArgument = getStylesArgument(referencePath);\n\n    if (!stylesArgument) {\n      throw \"Styles map argument must be provided\";\n    }\n\n    const programPath = referencePath.findParent(parentPath =>\n      parentPath.isProgram(),\n    );\n    referencePath.parentPath.remove();\n    const firstImportDeclarationNode = programPath\n      .get(\"body\")\n      .find(node => t.isImportDeclaration(node));\n\n    const firstNonImportDeclarationNode = programPath\n      .get(\"body\")\n      .find(node => !t.isImportDeclaration(node));\n\n    const getStyleNameIdentifier = programPath.scope.generateUidIdentifier(\n      \"getStyleName\",\n    );\n\n    const bindStyleNames = programPath.scope.generateUidIdentifier(\n      \"bindStyleNames\",\n    );\n\n    const bindImplementation = marcoConfig.enableMemo\n      ? `${name}/dist/bindStyleNameMemo`\n      : `${name}/dist/bindStyleNamePure`;\n    const helperImportDeclaration = t.importDeclaration(\n      [t.importDefaultSpecifier(bindStyleNames)],\n      t.stringLiteral(bindImplementation),\n    );\n\n    const bindedStylesDeclaration = t.variableDeclaration(\"const\", [\n      t.variableDeclarator(\n        getStyleNameIdentifier,\n        t.callExpression(bindStyleNames, [\n          stylesArgument,\n          marcoConfig.warning\n            ? t.booleanLiteral(true)\n            : t.booleanLiteral(false),\n        ]),\n      ),\n    ]);\n\n    firstImportDeclarationNode.insertBefore(helperImportDeclaration);\n    firstNonImportDeclarationNode.insertBefore(bindedStylesDeclaration);\n\n    programPath.traverse(visitor(t, getStyleNameIdentifier, marcoConfig));\n  });\n};\n\nexport default createMacro(myMacro, { configName: \"reactCssModulesMacro\" });\n"],"names":["createMacro","require","name","defaultConfig","enableMemo","targetTag","warning","ensureAttrName","attr","references","babel","marcoConfig","config","macro","t","types","forEach","referencePath","stylesArgument","parent","arguments","programPath","findParent","parentPath","isProgram","remove","firstImportDeclarationNode","get","find","node","isImportDeclaration","firstNonImportDeclarationNode","getStyleNameIdentifier","scope","generateUidIdentifier","bindStyleNames","bindImplementation","helperImportDeclaration","importDeclaration","importDefaultSpecifier","stringLiteral","bindedStylesDeclaration","variableDeclaration","variableDeclarator","callExpression","booleanLiteral","insertBefore","traverse","JSXElement","path","openingElement","attributes","length","spreadAttr","isJSXSpreadAttribute","findJSXSpreadAttr","classNameFromSpread","spread","memberExpression","argument","identifier","getMemberExpressionFromSpread","styleNameAttrIndex","map","isJSXAttribute","indexOf","findStyleNameAttrIndex","styleNameAttr","styleNameAttrPayload","isStringLiteral","value","stringValueReplacement","split","val","arrayExpression","expression","getStyleNameAttrPayload","styleNameExp","filter","Boolean","classNameAttr","findClassNameAttr","isJSXExpressionContainer","JSXExpressionContainer","binaryExpression","removeStyleNameAttr","newClassNameAttr","JSXAttribute","jsxIdentifier","createClassNameAttr","spreadIndex","JSXSpreadAttribute","ArrowFunctionExpression","BlockStatement","VariableDeclaration","VariableDeclarator","ObjectExpression","SpreadElement","ExpressionStatement","UnaryExpression","StringLiteral","ReturnStatement","createClassNameOmmitedSpread","visitor","configName"],"mappings":"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"}